#+property: header-args:elvish :tangle chain.elv
#+property: header-args :mkdirp yes :comments no
#+startup: indent


#+title: Elvish Chain theme prompt
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+begin_src elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/elvish-themes/blob/master/chain.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

* Introduction

This is my implementation for [[http://elvish.io][Elvish]] of the /Chain/ prompt theme,
based on the original fish theme at
https://github.com/oh-my-fish/theme-chain.

Ported to Elvish by Diego Zamboni <diego@zzamboni.org>.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[file:chain.elv][chain.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#introduction][Introduction]]
- [[#use][Use]]
- [[#implementation][Implementation]]
  - [[#base-code-and-default-values][Base code and default values]]
  - [[#general-utility-functions][General utility functions]]
  - [[#built-in-segment-definitions][Built-in Segment Definitions]]
    - [[#git-related-segments][git-related segments]]
    - [[#dir][=dir=]]
    - [[#su][=su=]]
    - [[#timestamp][=timestamp=]]
    - [[#arrow][=arrow=]]
  - [[#chain--and-prompt-building-functions][Chain- and prompt-building functions]]
  - [[#initialization][Initialization]]

* Use

To use this theme, first install the [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]]
package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish :tangle no
  epm:install github.com/zzamboni/elvish-themes
#+end_src

You can do this interactively or from your =~/.elvish/rc.elv= file. If
you want to put this in your =rc.elv= so that the package is
automatically installed when needed, and avoid having a message
printed every time the shell starts, you can add the
=&silent-if-installed=$true= option to the above command.

Add the following to you =~/.elvish/rc.elv= file to load and configure
the theme:

#+begin_src elvish :tangle no
  use github.com/zzamboni/elvish-themes/chain
#+end_src

If you want the prompt to be shown using bold fonts, set the
following:

#+begin_src elvish :tangle no
  chain:bold-prompt = $true
#+end_src

The default Elvish prompt settings work fine, but if you want to fine
tune them, check the [[https://elvish.io/ref/edit.html#prompts][Prompts]] documentation. For example, if you want
to keep the prompt from showing inverted when "stale" (this may happen
if you use git segments and are in a large git repo), you could set
the stale-prompt transformer to an identity function:

#+begin_src elvish :tangle no
  edit:prompt-stale-transform = $all~
#+end_src

If you want the prompt to be grayed out when stale, you can do the
following:

#+begin_src elvish :tangle no
  edit:prompt-stale-transform = { each [x]{ edit:styled $x[text] "gray" } }
#+end_src

 The chains on both sides can be configured by assigning to
=theme:chain:prompt-segments= and =theme:chain:rprompt-segments=,
respectively. These variables must be arrays, and the given segments
will be automatically linked by =$theme:chain:glyph[chain]=. Their
default values are:

#+begin_src elvish
  prompt-segments-defaults = [ su dir git-branch git-combined arrow ]
  rprompt-segments-defaults = [ ]
#+end_src

Each element can be any of the following:

- The name of one of the built-in segments. Available segments: =arrow=,
  =timestamp=, =su=, =dir=, =git-branch=, =git-dirty=, =git-untracked=,
  =git-deleted=, =git-ahead=, =git-behind=, =git-staged=, =git-combined= (which
  combines in a single segment all the other git status indicators)
- A string or the output of [[https://elvish.io/ref/edit.html#editstyled][edit:styled]], which will be displayed
  as-is.
- A lambda, which will be called and its output displayed
- The output of a call to =chain:segment <style> <strings>=, which
  returns a "proper" segment, enclosed in square brackets and styled
  as requested.

You can customize the glyphs and styles used for the different
segments by assigning to the corresponding elements of =chain:glyph= and
=chain:segment-style=, respectively.

* Implementation

** Base code and default values

Load the regular expression library.

#+begin_src elvish
  use re
#+end_src

We use [[https://github.com/muesli/elvish-libs/blob/master/git.elv][muesli's git library]] for the git functions.

#+begin_src elvish
  use github.com/muesli/elvish-libs/git
#+end_src

Set up the default values for the chains (all can be configured by
assigning to the appropriate variable):

#+begin_src elvish
  prompt-segments = $prompt-segments-defaults
  rprompt-segments = $rprompt-segments-defaults
#+end_src

Set up the default values for the glyphs used in the different
chains. Note that some of the Unicode glyphs may need an extra space
after them so that the character does not run into the next one in the
terminal. This is highly dependent on the font you use, so please fine
tune as needed. The default values work fine for the [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] font
I use.

#+begin_src elvish
  glyph = [
    &git-branch=    "⎇"
    &git-dirty=     "✎ "
    &git-ahead=     "⬆"
    &git-behind=    "⬇"
    &git-staged=    "✔"
    &git-untracked= "+"
    &git-deleted=   "-"
    &su=            "⚡"
    &chain=         "─"
    &arrow=         ">"
  ]
#+end_src

Styling for each built-in segment. The value must be a valid argument
to [[https://elvish.io/ref/edit.html#editstyled][=edit:styled=]].

#+begin_src elvish
  segment-style = [
    &git-branch=    blue
    &git-dirty=     yellow
    &git-ahead=     "38;5;52"
    &git-behind=    "38;5;52"
    &git-staged=    "38;5;22"
    &git-untracked= "38;5;52"
    &git-deleted=   "38;5;52"
    &su=            yellow
    &chain=         default
    &arrow=         green
    &dir=           cyan
    &timestamp=     gray
  ]
#+end_src

To how many letters to abbreviate directories in the path - 0 to show in full.

#+begin_src elvish
  prompt-pwd-dir-length = 1
#+end_src

Format to use for the =timestamp= segment, in [[http://man7.org/linux/man-pages/man3/strftime.3.html][strftime(3)]] format.

#+begin_src elvish
  timestamp-format = "%R"
#+end_src

User ID that will trigger the =su= segment. Defaults to root (UID 0).

#+begin_src elvish
  root-id = 0
#+end_src

Whether the prompt should be bold.

#+begin_src elvish
  bold-prompt = $false
#+end_src

** General utility functions

Internal function to return a styled string, or plain if =color= is
"default".

#+begin_src elvish
  fn -colorized [what color]{
    if (!=s $color default) {
      if $bold-prompt {
        color = $color";bold"
      }
      edit:styled $what $color
    } else {
      put $what
    }
  }
#+end_src

The =-colorized-glyph= returns the glyph for the given segment, with its
corresponding style.

#+begin_src elvish
  fn -colorized-glyph [segment-name]{
    -colorized $glyph[$segment-name] $segment-style[$segment-name]
  }
#+end_src

Build a prompt segment in the given style, surrounded by square
brackets. The first argument can be a style argument understood by
=edit:styled=, or the name of one of the predefined segments. In the
latter case, the style is taken from the =$segment-style= map, and if a
glyph for that segment name exists in the =$glyph= map, it is
automatically prepended to the given text.

#+begin_src elvish
  fn prompt-segment [segment-or-style @texts]{
    style = $segment-or-style
    if (has-key $segment-style $segment-or-style) {
      style = $segment-style[$segment-or-style]
    }
    if (has-key $glyph $segment-or-style) {
      texts = [ $glyph[$segment-or-style] $@texts ]
    }
    text = "["(joins ' ' $texts)"]"
    -colorized $text $style
  }
#+end_src

** Built-in Segment Definitions

This is where the built-in segments are defined. We assign the
corresponding functions to elements of the =$segment= map, indexed by
their segment name. The segment names need to correspond between the
=$segment=, =$glyph= and =$segment-style= maps.

#+begin_src elvish
  segment = [&]
#+end_src

*** git-related segments

Note that all the git-related segment functions only produce an output
if the current directory contains a git repository.

We define a module-level variable which contains the latest git
information. It gets populated once-per-prompt by the =-parse-git=
function, and the information is used by all the segments.

#+begin_src elvish
  last-status = [&]
#+end_src

The =-any-staged= function indicates whether there are any staged
changes (can be files added, deleted, modified, renamed or copied),
and is used below to extend the results from =git:status=.

#+begin_src elvish
  fn -any-staged {
    count [(each [k]{
          explode $last-status[$k]
    } [staged-modified staged-deleted staged-added renamed copied])]
  }
#+end_src

The =-parse-git= function calls =git:status= to get the git status of the
current directory. It extends the results with the result from
=-any-staged= to have an easy indicator of staged files.

#+begin_src elvish
  fn -parse-git {
    last-status = (git:status)
    last-status[any-staged] = (-any-staged)
  }
#+end_src

The =git-branch= segment indicates the current branch name. If we are in
a detached-branch state, we return the first 6 digits of the commit
ID.

#+begin_src elvish
  segment[git-branch] = {
    branch = $last-status[branch-name]
    if (not-eq $branch "") {
      if (eq $branch '(detached)') {
        branch = $last-status[branch-oid][0:7]
      }
      prompt-segment git-branch $branch
    }
  }
#+end_src

The =-show-git-indicator= function takes a git segment name and returns
whether it should be shown, depending on the information stored in
=$last-status=. Since the git segment names do not correspond one-to-one
with the elements of =$last-status=, we do here the mapping between
them.

#+begin_src elvish
  fn -show-git-indicator [segment]{
    status-name = [
      &git-dirty=     local-modified
      &git-ahead=     rev-ahead
      &git-behind=    rev-behind
      &git-staged=    any-staged
      &git-untracked= untracked
      &git-deleted=   local-deleted
    ]
    value = $last-status[$status-name[$segment]]
    # The indicator must show if the element is >0 or a non-empty list
    if (eq (kind-of $value) list) {
      not-eq $value []
    } else {
      > $value 0
    }
  }
#+end_src

Generic function to display a git prompt segment.

#+begin_src elvish
  fn -git-prompt-segment [segment]{
    if (-show-git-indicator $segment) {
      prompt-segment $segment
    }
  }
#+end_src

We support the following git indicator segments:

#+begin_src elvish
  -git-indicator-segments = [untracked deleted dirty staged ahead behind]
#+end_src

- The =git-dirty= segment indicates whether any files are "dirty"
  (modified locally).
- The =git-ahead= and =git-behind= segments indicate whether the current
  repository is ahead or behind of the upstream remote, if any.
- The =git-staged=, =git-untracked= and =git-deleted= segments indicate
  whether there are staged-but-uncommited, untracked or
  deleted-but-still-tracked files, respectively.

Using =-git-prompt-segment=, we define all these git segments.

#+begin_src elvish
  each [ind]{
    segment[git-$ind] = { -git-prompt-segment git-$ind }
  } $-git-indicator-segments
#+end_src

The =git-combined= segment combines all the different status indicators
in a single segment.

#+begin_src elvish
  segment[git-combined] = {
    indicators = [(each [ind]{
          if (-show-git-indicator git-$ind) { -colorized-glyph git-$ind }
    } $-git-indicator-segments)]
    if (> (count $indicators) 0) {
      put '[' $@indicators ']'
    }
  }
#+end_src

*** =dir=

For this segment we also need a support function, which returns
the current path with each directory name shortened to a maximum
of =$prompt-pwd-dir-length= characters.

#+begin_src elvish
  fn -prompt-pwd {
    tmp = (tilde-abbr $pwd)
    if (== $prompt-pwd-dir-length 0) {
      put $tmp
    } else {
      re:replace '(\.?[^/]{'$prompt-pwd-dir-length'})[^/]*/' '$1/' $tmp
    }
  }
#+end_src

#+begin_src elvish
  segment[dir] = {
    prompt-segment dir (-prompt-pwd)
  }
#+end_src

*** =su=

This segment outputs a glyph if the current user has a privileged
ID (=root= by default, with ID 0, but can be configured by
changing =$root-id=).

#+begin_src elvish
  segment[su] = {
    uid = (id -u)
    if (eq $uid $root-id) {
      prompt-segment su
    }
  }
#+end_src

*** =timestamp=

This segment simply outputs the current date according to the
format defined in =$timestamp-format=.

#+begin_src elvish
  segment[timestamp] = {
    prompt-segment timestamp (date +$timestamp-format)
  }
#+end_src

*** =arrow=

This segment prints the separator between the other chains and the
cursor.

#+begin_src elvish
  segment[arrow] = {
    -colorized $glyph[arrow]" " $segment-style[arrow]
  }
#+end_src

** Chain- and prompt-building functions

Given a segment specification, return the appropriate value,
depending on whether it's the name of a built-in segment, a lambda,
a string or an edit:styled

#+begin_src elvish
  fn -interpret-segment [seg]{
    k = (kind-of $seg)
    if (eq $k 'fn') {
      # If it's a lambda, run it
      $seg
    } elif (eq $k 'string') {
      if (has-key $segment $seg) {
        # If it's the name of a built-in segment, run its function
        $segment[$seg]
      } else {
        # If it's any other string, return it as-is
        put $seg
      }
    } elif (eq $k 'styled') {
      # If it's an edit:styled, return it as-is
      put $seg
    }
  }
#+end_src

Given a list of segments (which can be built-in segment names,
lambdas, strings or ~edit:styled~ objects), return the appropriate
chain, including the chain connectors.

#+begin_src elvish
  fn -build-chain [segments]{
    if (eq $segments []) {
      return
    }
    first = $true
    output = ""
    -parse-git
    for seg $segments {
      time = (-time { output = [(-interpret-segment $seg)] })
      if (> (count $output) 0) {
        if (not $first) {
          -colorized $glyph[chain] $segment-style[chain]
        }
        put $@output
        first = $false
      }
    }
  }
#+end_src

Finally, we get to the functions that build the left and right
prompts, respectively. These are basically wrappers around
=-build-chain= with the corresponding arguments.

#+begin_src elvish
  fn prompt {
    if (not-eq $prompt-segments []) {
      put (-build-chain $prompt-segments)
    }
  }

  fn rprompt {
    if (not-eq $rprompt-segments []) {
      put (-build-chain $rprompt-segments)
    }
  }
#+end_src

** Initialization

Default setup function, assigning our functions to =edit:prompt= and
=edit:rprompt=

#+begin_src elvish
  fn init {
    edit:prompt = $prompt~
    edit:rprompt = $rprompt~
  }
#+end_src

We call the =init= function automatically on module load.

#+begin_src elvish
  init
#+end_src
