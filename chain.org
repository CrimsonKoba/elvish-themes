#+property: header-args:elvish :tangle chain.elv
#+property: header-args :mkdirp yes :comments no
#+startup: indent


#+title: Elvish Chain theme prompt
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+begin_src elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/elvish-themes/blob/master/chain.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

* Introduction

This is my implementation for [[http://elvish.io][Elvish]] of the /Chain/ prompt theme,
based on the original fish theme at
https://github.com/oh-my-fish/theme-chain.

Ported to Elvish by Diego Zamboni <diego@zzamboni.org>.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy
to explain. See [[file:chain.elv][chain.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#introduction][Introduction]]
- [[#use][Use]]
- [[#implementation][Implementation]]
  - [[#base-code-and-default-values][Base code and default values]]
  - [[#general-utility-functions][General utility functions]]
  - [[#built-in-segment-definitions][Built-in Segment Definitions]]
    - [[#git-related-segments][git-related segments]]
    - [[#dir][=dir=]]
    - [[#su][=su=]]
    - [[#timestamp][=timestamp=]]
    - [[#arrow][=arrow=]]
  - [[#default-segment-declarations][Default segment declarations]]
  - [[#chain--and-prompt-building-functions][Chain- and prompt-building functions]]
  - [[#initialization][Initialization]]

* Use

To use this theme, first install the [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]]
package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish :tangle no
  epm:install github.com/zzamboni/elvish-themes
#+end_src

You can do this interactively or from your =~/.elvish/rc.elv= file. If
you want to put this in your =rc.elv= so that the package is
automatically installed when needed, and avoid having a message
printed every time the shell starts, you can add the
=&silent-if-installed=$true= option to the above command.

Add the following to you =~/.elvish/rc.elv= file to load and configure
the theme:

#+begin_src elvish :tangle no
  use github.com/zzamboni/elvish-themes/chain
#+end_src

If you want the prompt to be shown using bold fonts, set the
following:

#+begin_src elvish :tangle no
  chain:bold_prompt = $true
#+end_src

You should use the =$edit:-prompts-max-wait= variable to automatically
cache the prompt, particularly when using any of the git-related
segments, which can produce slowdowns in large repositories:

#+begin_src elvish :tangle no
  edit:-prompts-max-wait = 0.01
#+end_src

The chains on both sides can be configured by assigning to
=theme:chain:prompt_segments= and =theme:chain:rprompt_segments=,
respectively. These variables must be arrays, and the given segments
will be automatically linked by =$theme:chain:glyph[chain]=. Their
default values are:

#+name: prompt_segment_defaults
#+begin_src elvish :tangle no
  prompt_segments = [ su dir git_branch git_combined arrow ]
  rprompt_segments = [ ]
#+end_src

Each element can be any of the following:

- The name of one of the built-in segments. Available segments: =arrow=,
  =timestamp=, =su=, =dir=, =git_branch=, =git_dirty=, =git_untracked=, =git_ahead=,
  =git_behind=, =git_staged=, =git_combined= (which combines in a single
  segment all the other git status indicators)
- A string or the output of [[https://elvish.io/ref/edit.html#editstyled][edit:styled]], which will be displayed
  as-is.
- A lambda, which will be called and its output displayed
- The output of a call to =chain:segment <style> <strings>=, which
  returns a "proper" segment, enclosed in square brackets and styled
  as requested.

* Implementation

** Base code and default values

Load the regular expression library.

#+begin_src elvish
  use re
#+end_src

We use [[https://github.com/muesli/elvish-libs/blob/master/git.elv][muesli's git library]] for the git functions.

#+begin_src elvish
  use github.com/muesli/elvish-libs/git
#+end_src

Set up the default values for the chains (all can be configured by
assigning to the appropriate variable):

#+begin_src elvish :noweb yes
  <<prompt_segment_defaults>>
#+end_src

Set up the default values for the glyphs used in the different
chains. Note that some of the Unicode glyphs may need an extra space
after them so that the character does not run into the next one in the
terminal. This is highly dependent on the font you use, so please fine
tune as needed. The default values work fine for the [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] font
I use.

#+begin_src elvish
  glyph = [
    &prompt=        ">"
    &git_branch=    "⎇"
    &git_dirty=     "✎ "
    &git_ahead=     "⬆"
    &git_behind=    "⬇"
    &git_staged=    "✔"
    &git_untracked= "+"
    &su=            "⚡"
    &chain=         "─"
  ]
#+end_src

Styling for each built-in segment. The value must be a valid argument
to [[https://elvish.io/ref/edit.html#editstyled][=edit:styled=]].

#+begin_src elvish
  segment_style = [
    &chain=      default
    &su=         yellow
    &dir=        cyan
    &git_branch= blue
    &git_dirty=  yellow
    &git_ahead=  "38;5;52"
    &git_behind= "38;5;52"
    &git_staged= "38;5;22"
    &git_untracked= "38;5;52"
    &timestamp=  gray
  ]
#+end_src

To how many letters to abbreviate directories in the path - ~0~ to show in full.

#+begin_src elvish
  prompt_pwd_dir_length = 1
#+end_src

Format to use for the 'timestamp' segment, in [[http://man7.org/linux/man-pages/man3/strftime.3.html][strftime(3)]] format.

#+begin_src elvish
  timestamp_format = "%R"
#+end_src

User ID that will trigger the "su" segment. Defaults to root.

#+begin_src elvish
  root_id = 0
#+end_src

Whether the prompt should be bold.

#+begin_src elvish
  bold_prompt = $false
#+end_src

** General utility functions

Internal function to return a styled string, or plain if =color= is
"default".

#+begin_src elvish
  fn -colorized [what color]{
    if (!=s $color default) {
      if $bold_prompt {
        color = $color";bold"
      }
      edit:styled $what $color
    } else {
      put $what
    }
  }
#+end_src

The =-colorized-glyph= returns the glyph for the given segment, with its
corresponding style.

#+begin_src elvish
  fn -colorized-glyph [segment_name]{
    -colorized $glyph[$segment_name] $segment_style[$segment_name]
  }
#+end_src

Build a prompt segment in the given style, surrounded by square
brackets.

#+begin_src elvish
  fn prompt_segment [style @texts]{
    text = "["(joins ' ' $texts)"]"
    -colorized $text $style
  }
#+end_src

** Built-in Segment Definitions

This is where the built-in segments are defined.

*** git-related segments

Note that all the git-related segment functions only produce an output
if the current directory contains a git repository.

We define a few module-level variables which keep track of the latest
git information. They get populated once-per-prompt by the =-parse_git=
function, to avoid calling git multiple times during a single prompt
generation.

#+begin_src elvish
  last_git_ahead = 0
  last_git_behind = 0
  last_git_dirty = 0
  last_git_untracked = 0
  last_staged_count = 0
#+end_src

#+begin_src elvish
  fn -parse_git {
    last_git_ahead last_git_behind = (git:rev_count)
    last_git_dirty last_git_untracked = (git:change_count)
    last_staged_count = (git:staged_count)
  }
#+end_src

The =git_branch= segment indicates the current branch name.

#+begin_src elvish
  fn segment_git_branch {
    branch = (git:branch_name)
    if (not-eq $branch "") {
      prompt_segment $segment_style[git_branch] $glyph[git_branch] $branch
    }
  }
#+end_src

The =git_dirty= segment indicates whether any files are "dirty"
(modified locally).

#+begin_src elvish
  fn segment_git_dirty {
    if (> $last_git_dirty 0) {
      prompt_segment $segment_style[git_dirty] $glyph[git_dirty]
    }
  }
#+end_src

The =git_ahead= and =git_behind= segments indicate whether the current
repository is ahead or behind of the upstream remote, if any.

#+begin_src elvish
  fn segment_git_ahead {
    if (> $last_git_ahead 0) {
      prompt_segment $segment_style[git_ahead] $glyph[git_ahead]
    }
  }

  fn segment_git_behind {
    if (> $last_git_behind 0) {
      prompt_segment $segment_style[git_behind] $glyph[git_behind]
    }
  }
#+end_src

The =git_staged= and =git_untracked= segments indicate whether there are
staged-but-uncommited or untracked files, respectively.

#+begin_src elvish
  fn segment_git_staged {
    if (> $last_staged_count 0) {
      prompt_segment $segment_style[git_staged] $glyph[git_staged]
    }
  }

  fn segment_git_untracked {
    if (> $last_git_untracked 0) {
      prompt_segment $segment_style[git_untracked] $glyph[git_untracked]
    }
  }
#+end_src

The =git_combined= segment combines all the different status indicators
in a single segment.

#+begin_src elvish
  fn segment_git_combined {
    indicators = []
    if (> $last_git_untracked 0) {
      indicators = [ $@indicators (-colorized-glyph git_untracked) ]
    }
    if (> $last_git_dirty 0) {
      indicators = [ $@indicators (-colorized-glyph git_dirty) ]
    }
    if (> $last_staged_count 0) {
      indicators = [ $@indicators (-colorized-glyph git_staged) ]
    }
    if (> $last_git_ahead 0) {
      indicators = [ $@indicators (-colorized-glyph git_ahead) ]
    }
    if (> $last_git_behind 0) {
      indicators = [ $@indicators (-colorized-glyph git_behind) ]
    }
    if (> (count $indicators) 0) {
      put '[' $@indicators ']'
    }
  }
#+end_src

*** =dir=

For this segment we also need a support function, which returns
the current path with each directory name shortened to a maximum
of =$prompt_pwd_dir_length= characters.

#+begin_src elvish
  fn -prompt_pwd {
    tmp = (tilde-abbr $pwd)
    if (== $prompt_pwd_dir_length 0) {
      put $tmp
    } else {
      re:replace '(\.?[^/]{'$prompt_pwd_dir_length'})[^/]*/' '$1/' $tmp
    }
  }
#+end_src

#+begin_src elvish
  fn segment_dir {
    prompt_segment $segment_style[dir] (-prompt_pwd)
  }
#+end_src

*** =su=

This segment outputs a glyph if the current user has a privileged
ID (=root= by default, with ID 0, but can be configured by
changing =$root_id=).

#+begin_src elvish
  fn segment_su {
    uid = (id -u)
    if (eq $uid $root_id) {
      prompt_segment $segment_style[su] $glyph[su]
    }
  }
#+end_src

*** =timestamp=

This segment simply outputs the current date according to the
format defined in =$timestamp_format=.

#+begin_src elvish
  fn segment_timestamp {
    prompt_segment $segment_style[timestamp] (date +$timestamp_format)
  }
#+end_src

*** =arrow=

This segment prints the separator between the other chains and the
cursor.

#+begin_src elvish
  fn segment_arrow {
    -colorized $glyph[prompt]" " green
  }
#+end_src

** Default segment declarations

Here we define the list of segment names and the function that
produces each one of them.

#+begin_src elvish
  # List of built-in segments
  segment = [
    &su=            $segment_su~
    &dir=           $segment_dir~
    &git_branch=    $segment_git_branch~
    &git_dirty=     $segment_git_dirty~
    &git_ahead=     $segment_git_ahead~
    &git_behind=    $segment_git_behind~
    &git_staged=    $segment_git_staged~
    &git_untracked= $segment_git_untracked~
    &git_combined=  $segment_git_combined~
    &arrow=         $segment_arrow~
    &timestamp=     $segment_timestamp~
  ]
#+end_src

** Chain- and prompt-building functions

Given a segment specification, return the appropriate value,
depending on whether it's the name of a built-in segment, a lambda,
a string or an edit:styled

#+begin_src elvish
  fn -interpret-segment [seg]{
    k = (kind-of $seg)
    if (eq $k 'fn') {
      # If it's a lambda, run it
      $seg
    } elif (eq $k 'string') {
      if (has-key $segment $seg) {
        # If it's the name of a built-in segment, run its function
        $segment[$seg]
      } else {
        # If it's any other string, return it as-is
        put $seg
      }
    } elif (eq $k 'styled') {
      # If it's an edit:styled, return it as-is
      put $seg
    }
  }
#+end_src

Given a list of segments (which can be built-in segment names,
lambdas, strings or ~edit:styled~ objects), return the appropriate
chain, including the chain connectors.

#+begin_src elvish
  fn -build-chain [segments]{
    first = $true
    output = ""
    -parse_git
    for seg $segments {
      time = (-time { output = [(-interpret-segment $seg)] })
      if (> (count $output) 0) {
        if (not $first) {
          -colorized $glyph[chain] $segment_style[chain]
        }
        put $@output
        first = $false
      }
    }
  }
#+end_src

Finally, we get to the functions that build the left and right
prompts, respectively. These are basically wrappers around
=-build-chain= with the corresponding arguments.

#+begin_src elvish
  fn prompt [@skipcheck]{
    put (-build-chain $prompt_segments)
  }

  fn rprompt [@skipcheck]{
    put (-build-chain $rprompt_segments)
  }
#+end_src

** Initialization

Default setup function, assigning our functions to =edit:prompt= and
=edit:rprompt=

#+begin_src elvish
  fn init {
    edit:prompt = $prompt~
    edit:rprompt = $rprompt~
  }
#+end_src

We call the =init= function automatically on module load.

#+begin_src elvish
  init
#+end_src
