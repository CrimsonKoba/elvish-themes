#+property: header-args:elvish :tangle chain.elv
#+property: header-args :mkdirp yes :comments no
#+startup: indent

#+title: Elvish Chain theme prompt
#+author: Diego Zamboni
#+email: diego@zzamboni.org

#+begin_src elvish :exports none
  # DO NOT EDIT THIS FILE DIRECTLY
  # This is a file generated from a literate programing source file located at
  # https://github.com/zzamboni/elvish-themes/blob/master/chain.org.
  # You should make any changes there and regenerate it from Emacs org-mode using C-c C-v t
#+end_src

This is my implementation for [[http://elvish.io][Elvish]] of the /Chain/ prompt theme, based on the original fish theme at https://github.com/oh-my-fish/theme-chain.

Ported to Elvish by Diego Zamboni <diego@zzamboni.org>.

This file is written in [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][literate programming style]], to make it easy to explain. See [[file:chain.elv][chain.elv]] for the generated file.

* Table of Contents                                          :TOC_3:noexport:
- [[#use][Use]]
- [[#implementation][Implementation]]
  - [[#base-code-and-default-values][Base code and default values]]
  - [[#general-utility-functions][General utility functions]]
  - [[#built-in-segment-definitions][Built-in Segment Definitions]]
    - [[#git-related-segments][git-related segments]]
    - [[#dir][dir]]
    - [[#su][su]]
    - [[#timestamp][timestamp]]
    - [[#session][session]]
    - [[#arrow][arrow]]
  - [[#chain--and-prompt-building-functions][Chain- and prompt-building functions]]
  - [[#initialization][Initialization]]
  - [[#bonus-useful-functions][Bonus useful functions]]

* Use

To use this theme, first install the [[https://github.com/zzamboni/elvish-themes][github.com/zzamboni/elvish-themes]] package using [[https://elvish.io/ref/epm.html][epm]]:

#+begin_src elvish :tangle no
  epm:install github.com/zzamboni/elvish-themes
#+end_src

You can do this interactively or from your =~/.elvish/rc.elv= file. If you want to put this in your =rc.elv= so that the package is automatically installed when needed, and avoid having a message printed every time the shell starts, you can add the =&silent-if-installed=$true= option to the above command.

Add the following to you =~/.elvish/rc.elv= file to load and configure the theme:

#+begin_src elvish :tangle no
  use github.com/zzamboni/elvish-themes/chain
#+end_src

If you want the prompt to be shown using bold fonts, set the following:

#+begin_src elvish :tangle no
  chain:bold-prompt = $true
#+end_src

The default Elvish prompt settings work fine, but if you want to fine tune them, check the [[https://elvish.io/ref/edit.html#prompts][Prompts]] documentation. For example, if you want to keep the prompt from appearing inverted when "stale" (this may happen if you use git segments and are in a large git repo), you could set =$edit:prompt-stale-transform= to an identity function:

#+begin_src elvish :tangle no
  edit:prompt-stale-transform = $all~
#+end_src

On the other hand, if you want the prompt to be grayed out when stale, you can do the following:

#+begin_src elvish :tangle no
  edit:prompt-stale-transform = { each [x]{ styled $x[text] "gray" } }
#+end_src

The prompt chains on both sides can be configured by assigning to =theme:chain:prompt-segments= and =theme:chain:rprompt-segments=, respectively. These variables must be arrays, and the given segments will be automatically linked by =$theme:chain:glyph[chain]=. Their default values are:

#+begin_src elvish
  prompt-segments-defaults = [ su dir git-branch git-combined arrow ]
  rprompt-segments-defaults = [ ]
#+end_src

Each element can be any of the following:

- The name of one of the built-in segments. Available segments: =arrow=, =timestamp=, =su=, =dir=, =session= (a glyph with a unique color for the current session, based on its PID), =git-branch=, =git-dirty=, =git-untracked=, =git-ahead=, =git-behind=, =git-staged=, =git-combined= (which combines in a single segment all the other git status indicators), =git-timestamp= (timestamp of the last git commit);
- A string or the output of [[https://elvish.io/ref/edit.html#editstyled][styled]], which will be displayed as-is;
- A lambda, which will be called and its output displayed;
- The output of a call to =chain:segment <style> <strings>=, which returns a "proper" segment, enclosed in square brackets and styled as requested.

You can customize the glyphs and styles used for the different segments by assigning to the corresponding elements of =chain:glyph= and =chain:segment-style=, respectively.

The value assigned to an element of =chain:segment-style= can be:

- Any valid argument to [[https://elvish.io/ref/edit.html#editstyled][styled]].
- The string =default= to indicate no special color (this will show in your regular terminal text color).
- The string =session= to produce a color based on the current process ID, which can be used to indicate a unique color for the current session. This is used by the =session= segment, but can be assigned to any segment.

The module also includes the =chain:summary-status= function, which provides a status summary of git repositories, using the =git-combined=, =git-branch= and =git-timestamp= segments. The list is presented in reverse chronological order according to their latest git commit. I use this to get a quick summary of the status of my most commonly-used repos. You can store the default list of repositories in =$chain:summary-repos=, or simply pass them as arguments:

#+begin_src elvish :tangle no
  [~]─> chain:summary-repos = [ ~/.elvish ~/.emacs.d ~/.hammerspoon]
  [~]─> chain:summary-status
  [2019-04-30] [OK] [⎇ master] ~/.emacs.d
  [2019-04-21] [OK] [⎇ master] ~/.hammerspoon
  [2019-04-14] [OK] [⎇ master] ~/.elvish
  [~]─> chain:summary-status ~/.elvish/lib/github.com/zzamboni/*
  [2019-04-28] [OK] [⎇ master] ~/.elvish/lib/github.com/zzamboni/elvish-modules
  [2019-03-26] [OK] [⎇ master] ~/.elvish/lib/github.com/zzamboni/elvish-completions
  [2018-09-01] [+●] [⎇ master] ~/.elvish/lib/github.com/zzamboni/elvish-themes
#+end_src

* Implementation

** Base code and default values

Load the regular expression library.

#+begin_src elvish
  use re
#+end_src

We use [[https://github.com/href/elvish-gitstatus][href's gitstatus]] library for the git functions.

#+begin_src elvish
  use github.com/href/elvish-gitstatus/gitstatus
#+end_src

Set up the default values for the chains (all can be configured by assigning to the appropriate variable):

#+begin_src elvish
  prompt-segments = $prompt-segments-defaults
  rprompt-segments = $rprompt-segments-defaults
#+end_src

Set up the default values for the glyphs used in the different chains. Note that some of the Unicode glyphs may need an extra space after them so that the character does not run into the next one in the terminal. This is highly dependent on the font you use, so please fine tune as needed. The default values work fine for the [[http://levien.com/type/myfonts/inconsolata.html][Inconsolata]] font I use.

#+begin_src elvish
  default-glyph = [
    &git-branch=    "⎇"
    &git-dirty=     "●"
    &git-ahead=     "⬆"
    &git-behind=    "⬇"
    &git-staged=    "✔"
    &git-untracked= "+"
    &git-deleted=   "-"
    &su=            "⚡"
    &chain=         "─"
    &session=       "▪"
    &arrow=         ">"
  ]
#+end_src

Styling for each built-in segment. The value must be a valid argument to =[[https://elvish.io/ref/edit.html#editstyled][styled]]=.

#+begin_src elvish
  default-segment-style = [
    &git-branch=    [ blue    ]
    &git-dirty=     [ yellow  ]
    &git-ahead=     [ red     ]
    &git-behind=    [ red     ]
    &git-staged=    [ green   ]
    &git-untracked= [ red     ]
    &git-deleted=   [ red     ]
    &git-combined=  [ default ]
    &git-timestamp= [ cyan    ]
    &su=            [ yellow  ]
    &chain=         [ default ]
    &arrow=         [ green   ]
    &dir=           [ cyan    ]
    &session=       [ session ]
    &timestamp=     [ gray    ]
  ]
#+end_src

The =$glyph= and =$segment-style= maps are where the user can assign their custom glyphs or styles. Both are empty by default. If an element does not exist in these variables, the corresponding default value is used.

#+begin_src elvish
  glyph = [&]
  segment-style = [&]
#+end_src

To how many letters to abbreviate directories in the path - 0 to show in full.

#+begin_src elvish
  prompt-pwd-dir-length = 1
#+end_src

Format to use for the =timestamp= segment, in [[http://man7.org/linux/man-pages/man3/strftime.3.html][strftime(3)]] format.

#+begin_src elvish
  timestamp-format = "%R"
#+end_src

User ID that will trigger the =su= segment. Defaults to root (UID 0).

#+begin_src elvish
  root-id = 0
#+end_src

Whether the prompt should be bold.

#+begin_src elvish
  bold-prompt = $false
#+end_src

The =git-get-timestamp= function gets executed to produce the text to be displayed in the =git-timestamp= module. You can change it if you want to change the format of what gets displayed.

#+begin_src elvish
  git-get-timestamp = { git log -1 --date=short --pretty=format:%cd }
#+end_src

** General utility functions

Function to choose a color based on the current value of =$pid=, as an indicator of the current session.

#+begin_src elvish
  fn -session-color {
    valid-colors = [ black red green yellow blue magenta cyan lightgray gray lightred lightgreen lightyellow lightblue lightmagenta lightcyan white ]
    put $valid-colors[(% $pid (count $valid-colors))]
  }
#+end_src

Internal function to return a styled string, or plain if =color= is "default". If =$color= is "session", then a unique color is chosen for the current session using the =-session-color= function.

#+begin_src elvish
  fn -colorized [what @color]{
    if (and (not-eq $color []) (eq (kind-of $color[0]) list)) {
      color = [(explode $color[0])]
    }
    if (and (not-eq $color [default]) (not-eq $color [])) {
      if (eq $color [session]) {
        color = [(-session-color)]
      }
      if $bold-prompt {
        color = [ $@color bold ]
      }
      styled $what $@color
    } else {
      put $what
    }
  }
#+end_src

We have two auxiliary functions to return the glyph or style corresponding to a given segment. Default values are stored in the module's =$default-glyph= and =$default-segment-style= variables, but the user can provide their own values by setting =$glyph= and =$segment-style= respectively.

#+begin_src elvish
  fn -glyph [segment-name]{
    if (has-key $glyph $segment-name) {
      put $glyph[$segment-name]
    } else {
      put $default-glyph[$segment-name]
    }
  }
#+end_src

#+begin_src elvish
  fn -segment-style [segment-name]{
    if (has-key $segment-style $segment-name) {
      put $segment-style[$segment-name]
    } else {
      put $default-segment-style[$segment-name]
    }
  }
#+end_src

The =-colorized-glyph= returns the glyph for the given segment, with its corresponding style. If extra arguments are given, they are concatenated after the glyph.

#+begin_src elvish
  fn -colorized-glyph [segment-name @extra-text]{
    -colorized (-glyph $segment-name)(joins "" $extra-text) (-segment-style $segment-name)
  }
#+end_src

Build a prompt segment in the given style, surrounded by square brackets. The first argument can be a style argument understood by =styled=, or the name of one of the predefined segments. In the latter case, the style is taken from the =$segment-style= map, and if a glyph for that segment name exists in the =$glyph= map, it is automatically prepended to the given text.

#+begin_src elvish
  fn prompt-segment [segment-or-style @texts]{
    style = $segment-or-style
    if (has-key $default-segment-style $segment-or-style) {
      style = (-segment-style $segment-or-style)
    }
    if (has-key $default-glyph $segment-or-style) {
      texts = [ (-glyph $segment-or-style) $@texts ]
    }
    text = "["(joins ' ' $texts)"]"
    -colorized $text $style
  }
#+end_src

** Built-in Segment Definitions

This is where the built-in segments are defined. We assign the corresponding functions to elements of the =$segment= map, indexed by their segment name. The segment names need to correspond between the =$segment=, =$glyph= and =$segment-style= maps.

#+begin_src elvish
  segment = [&]
#+end_src

*** git-related segments

Note that all the git-related segment functions only produce an output if the current directory contains a git repository.

We define a module-level variable which contains the latest git information. It gets populated once-per-prompt by the =-parse-git= function, and the information is used by all the segments.

#+begin_src elvish
  last-status = [&]
#+end_src

The =-parse-git= function calls =gitstatus:query= to get the git status of the current directory. It extends the results with the result from =-any-staged= to have an easy indicator of staged files.

#+begin_src elvish
  fn -parse-git {
    last-status = (gitstatus:query $pwd)
  }
#+end_src

The =git-branch= segment indicates the current branch name. If we are in a detached-branch state, we return the first 6 digits of the commit ID.

#+begin_src elvish
  segment[git-branch] = {
    branch = $last-status[local-branch]
    if (not-eq $branch $nil) {
      if (eq $branch '') {
        branch = $last-status[commit][0:7]
      }
      prompt-segment git-branch $branch
    }
  }
#+end_src

The =git-timestamp= segment shows the last-commit timestamp from the current branch.

#+begin_src elvish
  segment[git-timestamp] = {
    ts = ($git-get-timestamp)
    prompt-segment git-timestamp $ts
  }
#+end_src

The =-show-git-indicator= function takes a git segment name and returns whether it should be shown, depending on the information stored in =$last-status=. Since the git segment names do not correspond one-to-one with the elements of =$last-status=, we do here the mapping between them.

(note that for now, =git-deleted= is the same as =git-dirty=, since =gitstatus= does not report deleted files separately, only as unstaged changes)

#+begin_src elvish
  fn -show-git-indicator [segment]{
    status-name = [
      &git-dirty=  unstaged        &git-staged=    staged
      &git-ahead=  commits-ahead   &git-untracked= untracked
      &git-behind= commits-behind  &git-deleted=   unstaged
    ]
    value = $last-status[$status-name[$segment]]
    # The indicator must show if the element is >0 or a non-empty list
    if (eq (kind-of $value) list) {
      not-eq $value []
    } else {
      and (not-eq $value $nil) (> $value 0)
    }
  }
#+end_src

Generic function to display a git prompt segment.

#+begin_src elvish
  fn -git-prompt-segment [segment]{
    if (-show-git-indicator $segment) {
      prompt-segment $segment
    }
  }
#+end_src

We support the following git indicator segments:

(note that for now, =git-deleted= still exists but is the same as =git-dirty=, since =gitstatus= does not report deleted files separately, only as unstaged changes, so it's removed from the default list above)

#+begin_src elvish
  #-git-indicator-segments = [untracked deleted dirty staged ahead behind]
  -git-indicator-segments = [untracked dirty staged ahead behind]
#+end_src

- The =git-dirty= segment indicates whether there are any local modifications (modified or deleted files).
- The =git-ahead= and =git-behind= segments indicate whether the current repository is ahead or behind of the upstream remote, if any.
- The =git-staged=, =git-untracked= segments indicate whether there are staged-but-uncommited or untracked files, respectively.

Using =-git-prompt-segment=, we define all these git segments.

#+begin_src elvish
  each [ind]{
    segment[git-$ind] = { -git-prompt-segment git-$ind }
  } $-git-indicator-segments
#+end_src

The =git-combined= segment combines all the different status indicators in a single segment. The =$segment-style[git-combined]= value determines the color used for the surrounding brackets.

#+begin_src elvish
  segment[git-combined] = {
    indicators = [(each [ind]{
          if (-show-git-indicator git-$ind) { -colorized-glyph git-$ind }
    } $-git-indicator-segments)]
    if (> (count $indicators) 0) {
      color = (-segment-style git-combined)
      put (-colorized '[' $color) $@indicators (-colorized ']' $color)
    }
  }
#+end_src

*** dir

For this segment we also need a support function, which returns the current path with each directory name shortened to a maximum of =$prompt-pwd-dir-length= characters.

#+begin_src elvish
  fn -prompt-pwd {
    tmp = (tilde-abbr $pwd)
    if (== $prompt-pwd-dir-length 0) {
      put $tmp
    } else {
      re:replace '(\.?[^/]{'$prompt-pwd-dir-length'})[^/]*/' '$1/' $tmp
    }
  }
#+end_src

#+begin_src elvish
  segment[dir] = {
    prompt-segment dir (-prompt-pwd)
  }
#+end_src

*** su

This segment outputs a glyph if the current user has a privileged ID (=root= by default, with ID 0, but can be configured by changing =$root-id=).

#+begin_src elvish
  segment[su] = {
    uid = (id -u)
    if (eq $uid $root-id) {
      prompt-segment su
    }
  }
#+end_src

*** timestamp

This segment simply outputs the current date according to the format defined in =$timestamp-format=.

#+begin_src elvish
  segment[timestamp] = {
    prompt-segment timestamp (date +$timestamp-format)
  }
#+end_src

*** session

This segment prints a session indicator in a color unique to the current session, based on its =$pid=.

#+begin_src elvish
  segment[session] = {
    prompt-segment session
  }
#+end_src

*** arrow

This segment prints the separator between the other chains and the cursor.

#+begin_src elvish
  segment[arrow] = {
    -colorized-glyph arrow " "
  }
#+end_src

** Chain- and prompt-building functions

Given a segment specification, return the appropriate value, depending on whether it's the name of a built-in segment, a lambda, a string or a =styled= object.

#+begin_src elvish
  fn -interpret-segment [seg]{
    k = (kind-of $seg)
    if (eq $k 'fn') {
      # If it's a lambda, run it
      $seg
    } elif (eq $k 'string') {
      if (has-key $segment $seg) {
        # If it's the name of a built-in segment, run its function
        $segment[$seg]
      } else {
        # If it's any other string, return it as-is
        put $seg
      }
    } elif (or (eq $k 'styled') (eq $k 'styled-text')) {
      # If it's a styled object, return it as-is
      put $seg
    }
  }
#+end_src

Given a list of segments (which can be built-in segment names, lambdas, strings or ~styled~ objects), return the appropriate chain, including the chain connectors.

#+begin_src elvish
  fn -build-chain [segments]{
    if (eq $segments []) {
      return
    }
    first = $true
    output = ""
    -parse-git
    for seg $segments {
      output = [(-interpret-segment $seg)]
      if (> (count $output) 0) {
        if (not $first) {
          -colorized-glyph chain
        }
        put $@output
        first = $false
      }
    }
  }
#+end_src

Finally, we get to the functions that build the left and right prompts, respectively. These are basically wrappers around =-build-chain= with the corresponding arguments.

#+begin_src elvish
  fn prompt {
    if (not-eq $prompt-segments []) {
      -build-chain $prompt-segments
    }
  }

  fn rprompt {
    if (not-eq $rprompt-segments []) {
      -build-chain $rprompt-segments
    }
  }
#+end_src

** Initialization

Default setup function, assigning our functions to =edit:prompt= and =edit:rprompt=

#+begin_src elvish
  fn init {
    edit:prompt = $prompt~
    edit:rprompt = $rprompt~
  }
#+end_src

We call the =init= function automatically on module load.

#+begin_src elvish
  init
#+end_src

** Bonus useful functions

=chain:summary-status= provides a summarized list of the =git-combined= and =git-branch= indicators for the repositories specified in =$chain:summary-repos=.

#+begin_src elvish
  summary-repos = []

  fn summary-status [@repos]{
    prev = $pwd
    if (eq $repos []) { repos = $summary-repos }
    each $echo~ $repos | sort | each [r]{
      try {
        cd $r
        -parse-git
        status = [($segment[git-combined])]
        if (eq $status []) {
          status = [(-colorized "[" session) (styled OK green) (-colorized "]" session)]
        }
        status = [($segment[git-timestamp]) ' ' $@status ' ' ($segment[git-branch])]
        echo &sep="" $@status ' ' (styled (tilde-abbr $r) blue)
      } except e {
        echo (styled '['(to-string $e)']' red) (styled (tilde-abbr $r) blue)
      }
    } | sort -r -k 1
    cd $prev
  }
#+end_src
